## Задача:
1. Получить топ-100 активов по обороту и топ-100 по дате листинга с CoinMarketCap / CoinGecko. (Активом считаем монету или токен)
2. Для каждого проверить, торгуется ли он на биржах из заданного списка {binance, bybit, kucoin} и какие еще есть альтернативы
3. Для каждого токена определить, в каких блокчейн-сетях он доступен (etherium, BNB Chain, Solana, …)
4. Выгрузить итоговые данные с информацией: актив, биржи для торговли, сети
5. Предложить приоритетность добавления полученных активов

## Требования:
* Использовать публичные API (CoinMarketCap и/или CoinGecko).
* Оформить результат в удобочитаемом формате (JSON или CSV)
* Обработать возможные ошибки и пропуски данных

## Описание решения 
Cтруктура выглядит вот так:
```commandline
.
├── config.py
├── main.py
├── output
│   ├── top-1-by-listing-date_2025-09-22_22-52-11.csv
│   └── top-1-by-volume_2025-09-22_22-52-11.csv
├── readme.md
├── requirements.txt
├── services
│   ├── base
│   │   ├── client.py
│   │   ├── exceptions.py
│   │   └── __init__.py
│   ├── coingecko
│   │   ├── client.py
│   │   └── __init__.py
│   └── __init__.py
└── utils
    ├── base
    │   ├── __init__.py
    │   └── parse_utils.py
    ├── coingecko
    │   ├── __init__.py
    │   └── parser.py
    ├── file_utils.py
    ├── __init__.py
    └── prioritization_utils.py
```
`config.py`
* Содержит глобальные настройки проекта.
* Пример: URL API CoinGecko, лимиты запросов, веса для приоритизации монет, количество записей для отчёта (REPORT_LIMIT).
* Используется везде, где нужны константы или конфигурации.

`main.py`
* Главный скрипт для запуска всего пайплайна.
* Асинхронно собирает данные по монетам (top by volume и top by listing date).
* Вызывает функции сборки отчёта и экспорта файлов в папку output/.

`output/`
* Папка для результатов скрипта.
* CSV-файлы называются по шаблону top-{limit}-by-{criteria}_{timestamp}.csv.
* Здесь хранятся финальные отчёты для анализа.

`/services` - Слой взаимодействия с внешними API (CoinGecko), содержит клиенты, базовые сервисы и исключения.
* `/base`
  * `/client.py` - Базовый асинхронный HTTP-клиент для работы с API. Реализует метод get(открыт к расширению и реализации других http-етодов через _make_request), с обработкой ошибок, ограничением частоты запросов и повторными попытками.
  * `/exceptions.py` - Исключение для обработки ошибок внешнего API.
* `/coingecko`
  * `/client.py` - Конкретная реализация клиента для CoinGecko. Методы:
    * get_coin_detailed_data(coin_id) – подробные данные о монете
    * get_top_by_volume(limit) – топ монет по объему торгов
    * get_top_by_listing_date(limit) – топ по дате листинга
    * get_exchanges(coin_id) – биржи, где торгуется монета

`/utils` - Служебные утилиты: парсинг данных, экспорт файлов, приоритизация.
* `/base`
  * `/parse_utils.py` - Общие функции для парсинга данных.
* `/coingecko`
  * `/parder.py` - одержит класс, который служит обёрткой над данными CoinGecko, предоставляя функции для парсинга информации о монете: биржах, на которых она торгуется, и сетях/платформах, на которых она существует.
  * `/prioritization_utils.py` - Логика приоритизации монет на основе рыночных данных.
* `/file_utils.py` - Экспорт собранных данных в CSV/JSON.

Поддержка добавление нового API требует только реализации клиента через BaseHTTPClient и ClientInterface, парсера через ParserInterface и функции расчета score(так как в каждом API могут отсутствовать/иметь отличное название), а основной отчетный движок остаётся неизменным:
* Интерфейс клиента (ClientInterface)
    - Любой новый источник должен реализовать методы: get_coin_detailed_data, get_top_by_volume, get_top_by_listing_date, get_exchanges.
    - Это гарантирует, что ReportBuilder сможет работать с любым источником единообразно.
* Класс HTTP-клиента для конкретного API
  - Для CoinGecko это CoinGeckoHTTPClient, который наследует интерфейс.
  - Для нового API создается свой класс, реализующий те же методы.
* Парсер (CoinGeckoParser)
  - Обрабатывает данные API и возвращает стандартизированные структуры (exchanges, networks).
  - Для нового API можно написать аналогичный парсер, реализующий те же методы (parse_coin_exchanges, parse_coin_networks).
* ReportBuilder
  - Принимает на вход любой объект source_client и parser.
  - Благодаря интерфейсам и унифицированной структуре парсеров можно подключать новые API без изменения логики построения отчета.

### Про подсчет приоритетности:
Реализована функция calculate_priority_enhanced, она вычисляет приоритет монеты на основе рыночных данных, активности на биржах и
присутствия в сетях. Используется для ранжирования криптовалют при составлении отчета (priority_score).

**Аргументы**:
* `coin_data` (Dict[str, Any]): Подробная информация о монете, полученная из API. 
        Основные используемые поля:
            - market_data.total_volume.usd
            - market_data.market_cap.usd
            - market_data.price_change_percentage_24h
            - market_data.price_change_percentage_7d
            - market_data.ath.usd
            - market_data.current_price.usd
            - platforms (для сетей)
* `exchanges_flags`: Словарь ключевых бирж, где монета торгуется.
        Значение True означает присутствие на бирже.
* `alt_exchanges`: Список альтернативных бирж, где доступна монета.
* `networks`: Список сетей, в которых реализована монета.

**Логика расчета приоритета:**
1. Нормализует объем торгов и рыночную капитализацию для сглаживания
           больших чисел.
2. Считает средневзвешенное изменение цены за 24 часа и 7 дней.
3. Рассчитывает "просадку от ATH" (All-Time High) как отношение текущей цены к максимальной исторической цене.
4. Вычисляет score за сети и биржи:
   - networks_score — доля используемых сетей от максимального значения.
   - exchange_score — доля ключевых бирж, на которых торгуется монета.
   - alt_score — доля альтернативных бирж с ограничением сверху.
5. Итоговый приоритет формируется как сумма всех компонент с весами, заданными  в settings.WEIGHTS(соответственно веса можно изменять).

